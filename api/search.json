[{"id":"8c6c59136f9c0c8c29b87ea646eed9d1","title":"操作系统","content":"3.1内存的基础知识1.什么是内存1.内存是用来存放数据的硬件。程序执行钱需要先放到内存中才能被CPU处理。\n\n\n\n\n3.2.装入的三种方式（完成逻辑地址到物理地址的转换）1.绝对装入在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。绝对装入适用于单道程序环境\n2.静态重定位又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。\n\n\n3.动态重定位又称动态运行时装入。编译、链接后的装入模块的地址都是从o开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。\n\n\n\n\n4.链接的三种方式需要将独立的逻辑地址合并成完整的逻辑地址需要进行链接\n1.静态链接:在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）,之后不再拆开。\n2.装入时动态链接:将各目标模块装入内存时，边装入边链接的链接方式。\n3.运行时动态链接:在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n3.3内存管理的概念\n3.4覆盖与交换1.内存空间扩充技术覆盖技术，交换技术，虚拟存储技术，引入覆盖技术解决程序大小超过物理内存总和问题。\n2.覆盖技术覆盖技术的思想:将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。\n内存中分为一个“固定区”和若干个“覆盖区”。\n需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)\n不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存\n覆盖技术缺点：对用户不透明，增加了用户编程负担，只用于早期操作系统中\n3.交换技术交换（对换）技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度)。\n\n4两者的区别覆盖技术是在一个进程中进行而交换技术是在多个进程中 \n3.5内存空间的分配和回收1.单一连续分配在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。\n内存中只能有一道用户程序，用户程序独占整个用户区空间。\n优点:实现简单;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护\n缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。（分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”）\n\n\n2.固定分区分配20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。\n分区大小相等:缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合\n分区大小不等：增加灵活性，可以满足不同大小的进程需求。\n操作系统需要建立一个数据结构――分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。\n当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。\n优点：实现简单，无外部碎片\n缺点：当用户程序太大时，可能所有分区都不能同时满足需求，此时不得不采用覆盖技术来解决，这又降低了性能，还有会产生内部碎片，内存利用率低\n3.动态分区分配动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。\n1.系统要用什么样的数据结构记录内存的使用情况?\n\n2.当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?\n把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。\n3.如何进行分区的分配与回收操作?\n略\n动态分区分配没有内部碎片，但是有外部碎片\n1.内部碎片分配给某进程的内存区域中，如果有些部分没有用上。\n2.外部碎片是指内存中的某些空闲分区由于太小而难以利用。\n3.紧凑如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑来解决外部碎片\n4.总结\n3.6动态分区分配算法1.首次适应算法算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。\n如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。\n2.最佳适应算法算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区。\n如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。\n缺点：每次都选最小的分区进行分配，会留下来越来越多很小的，难以利用的内存块，因此这种方法会产生很多外部碎片。\n3.最坏适应算法（最大适应算法）算法思想:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。\n如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。\n\n\n4.邻近适应算法算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。\n如何实现:空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。\n\n\n5.总结\n\n3.7内存管理1.分页存储管理\n\n页号&#x3D;逻辑地址&#x2F;页面长度（去除法整数部分）\n页内偏移量&#x3D;逻辑地址&#x2F;页面长度（去除法余数部分）\n2.逻辑地址结构：\n\n\n\n3.页表为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 页表记录进程页面和实际存放的内存块之间的对应关系。\n3.8基本地址变换机构基本地址转换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。\n\n\n在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。\n总结\n3.9具有快表的地址变换机构1.局部性原理1.时间局部性如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环)\n2.空间局部性一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的)\n2.快表快表，又称联想寄存器(TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。\n1.地址变换过程\n\n4.0两级页表1.单级页表存在的问题\n2.两级页表的原理、地址结构4.1文件存储管理\n4.2文件的基本操作1.打开文件\n2.关闭文件进程使用文件后要关闭文件，\n1.将进程打开文件表相应表项删除。\n2.回收分配给文件的内存空间等资源\n3.系统打开文件表的打开计数器count减一，count等于零则删除对应表项。\n3.读文件\n4.写文件\n5.总结\n4.3文件共享注意：多个用户共享统一个文件，意味着系统只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。\n1.基于索引节点的共享方式（硬链接）索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。\n\n2.基于符号连的共享方式（软链接）\n4.4文件保护1.口令保护\n2.加密保护\n3.访问控制\n4.总结\n4.5文件系统的层次结构\n\n4.6磁盘的结构1.磁盘，磁道，扇区磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。\n\n2.怎么在磁盘中读&#x2F;写数据\n3.盘面，柱面\n4.磁盘的物理地址\n5.磁盘的分类活动头磁盘：磁头可以移动。磁臂可以来回伸缩带动磁头定位磁道。\n\n\n固定头磁盘：磁头不可以移动，每个磁道有一个磁头。\n\n\n6.总结\n4.7磁盘调度算法1.磁盘读写操作需要的时间1.寻找时间在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间。\n\n\n2.延迟时间通过旋转磁盘，使磁头定位到目标扇区所需要的时间。\n\n\n3.传输时间从磁盘读出或向磁盘写入数据所经历的时间。\n\n\n4.总结延迟时间和传输时间都和磁盘转速有关，都是线性相关，转速是磁盘固有属性，因此操作系统无法优化这两个时间。\n2.算法1.先来先服务算法（FCFS）根据进程请求访问磁盘的先后顺序进行调度。\n\n\n优点：公平，如果请求访问的磁道比较集中的话，算法性能还算过得去。\n缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。\n2.最短寻找时间优先（SSTF）SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)\n\n\n3.扫描算法（SCAN）\n\n4.LOOK调度算法\n\n5.循环扫描算法（C-SCAN）\n\n6.C-LOOK调度算法\n\n3.总结\n4.8减少延迟时间的方法1.交替编号\n\n若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。\n具体做法是让编号相邻的扇区在物理上不相邻。\n2.磁盘地址结构的设计物理地址结构是柱面号，盘面号，扇区号。这种方式，在读取地址连续的磁盘块的时候，可以减少磁头移动消耗的时间。\n3.错位命名让相邻盘面的扇区编号错位。\n\n4.9磁盘的管理1.磁盘初始化\n2.引导块计算机开机时需要进行一系列初始化工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。\nROM：初始化程序可以放在ROM中（）只读存储器，ROM中的数据在出厂的时候就写入了，并且以后不能修改。ROM一般出厂就集成在了主板上。\n现在ROM中只是存放很小的自举装入程序，完整的程序放在磁盘的启动快中，启动快位于磁盘的固定位置。\n拥有启动分区的磁盘统称为启动磁盘（C盘）\n3.坏块管理\n\n5.0 I-O设备概念1.I-O控制器","slug":"操作系统","date":"2022-11-11T13:53:28.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"521d22a4a6d0170569a691b35603f80b","title":"Javaweb","content":"1.Session（重点）1.session和cookie的区别Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）\nsession是把用户的数据写到用户独占的Session中，服务器端保存（保存重要信息，减少服务器资源浪费）\nSession由服务器创建\n2.使用场景用来保存用户登录信息\n在整个网站中经常会使用的数据，我们将它保存在Session中;\n2.JSP1.什么是JSPJava Server Pages:Java服务器端页面，也和Servlet一样用于动态web技术\n最大的特点：\n写JSP就像是在写html\n区别：\nHTML只给用户提供静态数据\nJSP中可以嵌入JAVA代码，为用户提供动态数据\n2.JSP原理浏览器想服务器发送请求，不管访问什么资源，其实都是在访问servlet！\nJSP最终会被转换成一个java类\nJSP本质上就是一个Servlet类\n在JSP页面中，只要是JAVA代码就会被原封不动的输出，如果是HTML代码会被转换为\nout.write(&quot;&quot;);\n\n这样的格式输出到前端\n3.JSP基础语法JSP注释会在客户端显示，HTML不会\n4.JSP指令3.JavaBeanjavabean有特定的写法：\n必须要有一个无参构造器\n属性必须私有化\n必须有对应的get&#x2F;set方法，一般用来和数据库的字段做映射\n","slug":"Javaweb","date":"2022-11-11T13:53:28.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"3.存储系统1.双端口RAM和多模块存储器1.多体并行存储器1.高位交叉编址\n2.低位交叉编址\n实际上采用了“流水线”的方式并行存取，当存储周期为T时，存取时间为r时，为了使流水线不间断，，应该保证模块数m&gt;&#x3D;T&#x2F;r，如果m小于T&#x2F;r，则cpu需要等待r。\n若给定一个地址x，应该用它的体号来判断它属于第几个存储体。\n3.多模块存储器1.多体并行存储器\n2.单体多字存储器\n每次直接读一整行字，灵活性没有多体高，会读入一些没有意义的数据。但是速度都差不多，高位交叉的多体存储器相当于扩单纯的扩容，低位交叉的多体存储器相当于双通道，可以使吞吐量翻倍在连续访问时，\n2.双端口RAM\n2.Cache1.Cache工作原理cache被集成在CPU内部，cache用SRAM实现，速度快，成本高。\nRAM可分为静态存储器（Static Random Access Memory,SRAM）和动态存储器（Dynamic Random Access Memory）。SRAM中的存储单元相当于一个锁存器，只有0，1两个稳态；DRAM则是利用电容存储电荷来保存0和1两种状态，因此需要定时对其进行刷新，否则随着时间的推移，电容其中存储的电荷将逐渐消失。\nSRAM：读写速度快，生产成本高，多用于容量较小的高速缓冲存储器。\nDRAM：读写速度较慢，集成度高，生产成本低，多用于容量较大的主存储器。\n2.局部性原理1.空间局部性在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是邻近的（数组元素，顺序执行的指令代码）\n2.时间局部性在最近的未来要用到的信息，很可能是现在正在使用的信息（循环结构的指令代码）\n基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放到cache中\n3.性能分析命中率：CPU想要访问的信息已经在Cache中的比率\n设tc为访问一次Cache所需时间,tm为访问一次主存所需时间\nCache—主存系统的平均访问时间t为\nt &#x3D; Htc+(1 一H)(tc + tm)\n主存和Cache是以块为单位进行数据交换。\n\n3.Cache和主存的映射方式1.全相联映射主存块可以放在Cache任意位置（Cache块和主存块大小相等）\n\nCpu访问主存地址\n\n\n2.直接映射每个主存块只能放到一个特定的位置:Cache块号&#x3D;主存块号% Cache总块数\n若cache总块数&#x3D;2^n,则主存块号末尾n位直接反映它在Cache中的位置，将主存块号的其余位作为标记即可\n\n\n3.组相联映射Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置，组号&#x3D;主存块号%分组数\n\n\n4.替换算法1.随机算法（RAND）\n\n2.先进先出算法（FIFO）\n\n3.近期最少使用算法（LRU）\n4.最不经常使用算法（LFU）\n5.总结\n5.Cache写策略（确保主存中母本一致性）1.写命中1.写回法Cache设置脏位，当数据被修改是，脏位变成1。当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。减少了访存次数，但存在数据不一致的隐患。\n2.全写法当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲(write buffer)，访问主存次数增加，速度变慢，但更能保证数据一致性。\n使用写缓冲。CPU写的速度很快，若写操作不频繁，则效果很好。减写操作很频繁手感熊会因为写缓冲饱和发生阻塞。（写缓冲是SRAM实现的FIFO队列）\n2.写不命中1.写分配法写分配法(write-allocate)———当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配写回法使用。\n2.非写分配法非写分配法(not-write-allocate)—当CPU对Cache写不命中时只写入主存，不调入Cache。搭配全写法使用。\n3多级cache现代计算机常采用多级cache\n离CPU越近的速度越快，容量越小，离CPU越远的速度越慢，容量越大\n6.页式存储器1.定义一个程序（进程），在逻辑上被分为若干个大小相等的“页面”，页面大小和块大小相同，每个页面可以放入不同的主存块中。\n2.虚地址和实地址逻辑地址（虚地址）：程序员视角看到的地址，逻辑页号+页内地址\n物理地址（实地址）：实际在主存中的地址，主存块号+页内地址\nCPU执行的机器指令中，使用的是逻辑地址，因此需要页表将逻辑地址转变为物理地址，\n页表的作用是为了记录每个逻辑页面存放到那个主存块当中\n\n\n3.地址变换过程\n增加TLB\n\n4.注意快表中存储的是页表项的副本，Cache中存储的是主存块的副本。\n7.虚拟存储器1.页面虚拟存储器定义：把程序拆分成大小相等的页面\n\n有效位:这个页面是否已调入主存\n脏位:这个页面是否被修改过\n引用位:用于“页面置换算法”，比如，可以用来统计这个页面被访问过多少次\n物理页:即主存块号\n磁盘地址:即这个页面的数据在磁盘中的存放位置\n2.存储器层次化结构主存—辅存：实现虚拟存储系统，解决了主存容量不够的问题。\nCache—主存：解决了主存和CPU速度不匹配的问题。\n3.段式虚拟存储器定义：把程序按照功能模块拆分\n4.指令系统1.回忆计算机工作过程\n\n2.指令格式1.指令的定义是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。\n2.指令格式一条指令就是一组有意义的二进制代码，一条指令通常要包括操作码字段和地址码字段。 \n1.零地址指令（OP）不需要操作数，如空操作数，停机，关中断等指令，堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶\n2.一地址指令（OP + A1）\n\n\n\n3.按照指令长度分类定长操作码：指令系统中所有指令的操作码长度都相同，控制器的译码电路设计简单,但灵活性较低\n可变长操作码：指令系统中各指令的操作码长度可变，控制器的译码电路设计复杂,但灵活性较高\n4.按照操作类型分类\n\n3.总结\n\n4.扩展操作码定长指令字结构 + 可变长操作码（不同地址数的指令使用不同长度的操作码）\n通常情况下，对使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。\n\n\n5.指令寻址1.顺序寻址(PC)+“1”——&gt;PC\n2.转移寻址\n\n3.总结\n\n6.数据寻址5.中央处理器计算机工作过程：首先PC将指令给到MAR，MAR进入储存体再到MDR，MDR给到IR，IR将操作码部分给到CU，分析指令，再将操作码送到CU，分析完指令，将地址码送到MAR，，然后到存储体中找到相应的数据，给到MDR，，然后通过数据通路送到ACC。 \n1.CPU基本结构和功能1.指令控制完成取指令，分析指令，和执行指令的操作，即程序的顺序控制。\n2.操作控制一条指令的功能往往是由若干操作信号的组合来实现的。CPu管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。\n3.时间控制对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。\n4.数据加工对数据进行算术和逻辑运算\n5.中断处理对计算机运行过程中出现的异常情况和特殊请求进行处理。\n6.运算器对数据进行加工\n7.控制器协调并控制计算机各部件执行程序的指令序列,基本功能包括取指令、分析指令、执行指令\n2.运算器的基本结构\n3.控制器的基本结构\n4.CPU基本结构\n5.指令的执行过程1.指令周期CPU从主存中每取出并执一条指令所需的全部时间。\n\n\n\n\n\n\n6.数据通路的功能内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线;系统总线是指同一台计算机系统的各部件，如CPU、内存、通道和各类I&#x2F;o接口间互相连接的总线。\n1.寄存器之间的数据传送\n2.主存和CPU之间的数据传送\n3.执行算术或逻辑运算MDR传入IR，MDR里面也会保存一份。也可以直接从MDR传送到MAR。\n\n\n\n\n\n\n\n7.专用数据通路\n\n运算器ALU不是寄存器，数据会被放到累加器ACC中，\n\n\n\n\n\n8.控制器的设计1.硬布线控制器\n\n\n2.硬布线控制器的设计\n\n\n1–&gt;R是指向主存发出读信号。\n3.微程序控制器的基本原理（考察频率较高）1.微程序硬布线控制器：微操作控制信号有组合逻辑电路根据当前的指令码，状态和时序（时序信息包括机器周期和节拍），即使产生。\n程序：是指令组成的。\n微程序：由微指令序列组成，每一种指令对应一个微程序。\n指令是对程序执行步骤的描述，微指令是对指令执行步骤的描述\n指令是对微指令功能的“封装”\n一条微指令可能包含多个微命令，\n微命令和微操作是一一对应的。\n2.微程序控制器基本结构\n3.工作原理\n\n4.总结\n4.微指令的设计1.微指令的格式\n\n1.水平型微指令\n一条微指令可以定义多个可并行的微命令，微程序段，执行速度很快。但是微指令较长，编写微程序比较麻烦\n\n2.垂直型微指令\n一条微指令只能定义一个微命令，由微操作码字段规定具体功能。\n\n3.混合型微指令\n在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写;微程序也不长，执行速度加快。\n","slug":"计算机组成原理","date":"2022-11-11T13:33:06.356Z","categories_index":"","tags_index":"","author_index":"Aurora"}]