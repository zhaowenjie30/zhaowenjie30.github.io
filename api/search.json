[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"1.初识Python1.Python安装直接去官网Download Python | Python.org下载就可以\n2.Python解释器Python解释器，是一个计算机程序，用来翻译Python代码，并提交给计算机执行。\n\n\n\n\n\n3.常用快捷键\n2.Python基础语法1.字面量在代码中,被写下来的固定的值,\n\n\n2.注释\n\n3.变量在程序运行时，能储存计算结果或能表示值的抽象概念。简单的说，变量就是在程序运行时，记录数据用的\n\n4.type()语句\n\n通过这个可以知道数据类型是什么\n5.转换语句\n6.字符串的三种定义方式\n","slug":"Python笔记","date":"2022-12-01T16:44:11.149Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"1.金基德1996年&lt;鳄鱼藏尸日&gt;&lt;野兽之都&gt;\n1998年&lt;雏妓&gt;\n2000年&lt;真相&gt;\n2001年&lt;漂流欲室&gt;&lt;收信人不明&gt;\n2002年&lt;海岸线&gt;&lt;坏小子&gt;\n2003年&lt;春夏秋冬又一春&gt;\n2004年&lt;空房间&gt;&lt;撒玛利亚女孩&gt;\n2005年&lt;弓&gt;\n2006年&lt;时间&gt;\n2007年&lt;呼吸&gt;\n2008年&lt;悲梦&gt;\n2011年&lt;阿门&gt;\n2012年&lt;圣殇&gt;\n2013年&lt;莫比乌斯&gt;&lt;红色家族&gt;&lt;演员就是演员&gt;\n2014年&lt;一对一&gt;\n2015年&lt;无神&gt;\n2016年&lt;网&gt;\n2.奉俊昊2002年&lt;无血无泪&gt;\n2003年&lt;杀人回忆&gt;\n2004年&lt;三人三色&gt;\n2006年&lt;汉江怪物&gt;\n2008年&lt;东京!&gt;\n2009年&lt;母亲&gt;\n2013年&lt;雪国列车&gt;\n2014年&lt;海雾&gt;\n2017年&lt;玉子&gt;\n2019年&lt;寄生虫&gt;\n3.朴赞郁1992年&lt;月亮是太阳的梦想&gt;\n1997年&lt;三人组&gt;\n1999年&lt;审判&gt;\n2000年&lt;共同警备区&gt;&lt;天地男孩之激进党员&gt;\n2002年&lt;我要复仇&gt;&lt;奇异二人恋&gt;\n2003年&lt;六人视线&gt;\n2004年&lt;老男孩&gt;\n2005年&lt;亲切的金子&gt;&lt;少年去天国&gt;\n2006年&lt;机器人之恋&gt;\n2007年&lt;活着的邪恶&gt;\n2009年&lt;蝙蝠&gt;\n2011年&lt;波澜万丈&gt;\n2012年&lt;青出于蓝&gt;\n2013年&lt;斯托克&gt;&lt; v &gt;\n2016年&lt;小姐&gt;\n2020年&lt;分手的决心&gt;\n4.电影&lt;塔尔萨之王&gt;&lt;熔炉&gt;&lt;黄海&gt;&lt;实尾岛&gt;&lt;出租车司机&gt;&lt;我的野蛮女友&gt;&lt;看见恶魔&gt;&lt;追击者&gt;&lt;老男孩&gt;&lt;金福南杀事件始末&gt;&lt;蒙太奇&gt;\n&lt;局内人&gt;&lt;七天&gt;&lt;亲切的金子&gt;&lt;与犯罪的战争坏家伙的全盛时代&gt;&lt;杀人者的记忆法&gt;&lt;老千&gt;&lt;江南1970&gt;&lt;高校往事1978&gt;\n&lt;马粥街残酷史&gt;&lt;华尔街之狼&gt;&lt;恶女&gt;&lt;下女的诱惑&gt;&lt;工作女郎&gt;&lt;红字&gt;\n李钟硕&lt;杀人优越权&gt;\n","slug":"韩国电影","date":"2022-11-24T20:45:53.630Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Java基础概念1.人机交互1.人机交互的小故事施乐公司推出第一台图形化界面的电脑。\n图形化界面操作计算机缺点：消耗内存运行速度慢\nCMD：在windows系统中，也保留了利用命令行的方式操作计算机。可以打开文件，创建文件，删除文件等等。\n2.打开CMD1.win + R键\n2.输入cmd\n3.按下回车键\n3.常用的CMD命令\ndir隐藏的文件夹也可以展示出来，如果单词太长不想写可以按下tab键就可以关联出来。cdm里面大小写无所谓但是要区分中文英文符号\n关机:shutdown &#x2F;s\n重启:shutdown &#x2F;f\n注销:shutdown &#x2F;l\n新建文件夹:md test\n显示当前运行的进程：tasklist\n运行程序或命令:start 程序名\n如果是经常打开的软件，还要进入多层文件打开，太麻烦了，只要把常用软件记录的电脑的某个地方就可以了（环境变量）\n4.配置环境变量1.为什么配置环境变量？我们想要在任意的目录下都可以打开指定的软件.就可以把软件的路径配置到环境变量中。path环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。\n2.Java基础学习\n\n1.基础语法1.Java入门1.java是什么Java是一门非常火的计算机语言\n2.Java程序初体验3.jdk下载与安装bin目录下存放了各种工具命令。其中比较重要的有：javac和java\nconf目录下存放了相关配置文件\ninclude目录存放了一些平台特定的头文件\njmods目录下存放了各种模块\nlegal目录存放了各模块的授权文档 \nlib目录存放了工具的一些补充JAR包\n4.第一个程序helloworld1.用记事本编写程序，2.编译文件 3.运行程序。编译其实就是翻译，翻译成计算机可以看懂的内容\n首先cmd，进入指定文件夹，在cmd中执行javac 代码.java这步是编译文件然后再执行 java 代码\n\njavac是JDK提供的编译工具，我们通过这个工具，把当前路径下的文件编译成class文件\njava也是JDK提供的工具，用来运行class文件\t，运行时不加后缀名\n5.案例常见问题中英文符号问题\n6.环境变量配置path环境变量的目的是想要在任意的目录下都可以打开指定软件，就可以把软甲的指定路径配置到环境变量中。\n配置java的环境变量需要在高级系统设置中，找到环境变量，然后新建一个JAVA_HOME,里面写 jdk所在路径,然后再path中引用JAVA_HOME,后面是bin文件夹.\n\n\n7.Notepad++高级记事本,安装完毕后需要做一个简单的配置:修改默认语言和编码.如果在运行时出现乱码问题就使用这行代码javac -encoding gbk + 代码名称\n\n\n8.Java学习JavaSE是Java语言的标准版,用于桌面应用(用户只要打开程序,程序的界面就能让用户在最短的时间内找到他们需要的功能,同时带领用户完成他们的工作并得到很好的体验)的开发,是其他两个版本的基础.比如计算器,这个领域最合适的语言是C和C++\nJavaME用于嵌入式电子设备,或者小型移动设备 \nJavaEE用于web网站开发,这里领域很厉害,网站开发指的是浏览器＋服务器\n\n\n​\t\n编译型语言是整体翻译(C),解释性语言是按行翻译(Python),混合型语言\n\n\n6.JRE和JDK JDK由JVM虚拟机(Java运行的地方),核心类库(Java已经写好的东西,我们可以直接拿来用),开发工具组成(javac编译工具,java运行工具,jdb调试工具,jhat内存分析工具)\nJRE由JVM虚拟机,核心类库,运行工具组成.是java的运行环境,如果不需要编写代码安装一个JRE就可以运行代码\n2.Java基础语法1.注释注释是在程序指定的位置添加的说明性的信息,对代码的一种解释说明.\n\n\n2.关键字被Java赋予了特定含义的英文单词,关键字的字母全部小写\nclass关键字,用于创建一个类,类是Java中最基本的组成单元\n3.字面量\nnull不能直接打印,只能用字符串的形式打印.布尔类型的可以直接打印\n特殊字符:\\t \\r \\n\n\\t制表符:在打印的时候，把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。可以在制作表格的时候方便对齐.\n4.变量当某个数据经常发生改变时，我们也可以用变量存储。当数据变化时，只要修改变量里面记录的值即可。\n变量的定义格式: 数据类型 变量名 &#x3D; 数据值;\n变量的注意事项:只能存储一个值,变量名不允许重复定义,一条语句中一可以定义多个变量,变量在使用前一定要赋值,变量的作用域范围,\n5.数据类型分为基本数据类型和引用数据类型\n\n\n如果要定义long型变量要在后面加上l大小写都可以.建议使用大写字母L\n定义float型变量的时候数据值后面也要加一个大写的F作为后缀\n6.标识符标识符就是给类,方法,变量等起的名字.\n\n\n\n\n7.键盘录入Java帮我们写好了一个Scanner类可以帮助我们接受键盘输入的数字\n\n\n3.计算机的存储规则在计算机中,任意数据都是以二进制形成来存储的\n\n\n4.IDEA概述和下载IDEA项目结构:项目,模块,包,类\n\n\n5.运算符1.算数运算符\n\n数字相加:数字进行运算的时候,数据类型不一样,需要转成一样的,才能运算.\n隐式转换:取值范围小变大\n强制转换:取值范围大变小\n\n强制转换格式:目标数据类型 变量名 &#x3D; (目标数据类型) 被强转的类型\n字符串相加:\n2.自增自减运算符\n\n\n3.赋值运算符\n\n4.关系运算符\n\n5.逻辑运算符\n6.短路逻辑运算符\n\n7.三元运算符格式: 关系表达式 ? 表达式1 : 表达式2;\n8.运算符的优先级\n\n小括号优先于所有\n6.原码反码补码八个比特是一个字节.字节是计算机中最小的存储单元.\n利用原码对正数进行计算不会有问题,但是如果是负数的话就会出错,实际运算结果和我们预期的结果是相反的.\n反码:是为了解决原码不能计算负数问题出现的\n\n\n\n\n7.流程控制语句1.顺序结构一行一行按顺序执行语句\n2.分支结构if注意点,如果语句体中只有一句代码,大括号可以省略不写,\nswitch语句格式:\nswitch其他知识点:\ndafault可以省略但是不建议省略不写,dafault不一定是写在最下面的可以写在任意位置.\ncase穿透:break不能省略不写\nswitch新特性:\n\nif一般用在对范围的判断上面,switch把有限个选项列举出来,让我们任选其一.\n3.循环结构循环分类\nfor\nwhile\nfor和while对比:运行规则都一样,while一般在不知道循环范围的时候用的多,while(true)无限循环,如果要终止循环就需要在循环体内使用break来终止循环\n区别:\ndo…while循环\n先执行后判断\n8.循环高级1.无线循环\n2.跳转控制语句在循环过程中跳到其他语句中执行\n\n\n3.获取随机数Java帮我们写好了一个类叫Random,这个类可以生成随机数\n\n\n3.数组1.数组的定义数组是指一种容器,可以用来存储同种数据类型的多个值.在存储数据的时候,要考虑到隐式转换.\n\n\n2.数组的初始化在内存中,为数组开辟空间,将数据存入容器的过程\n\n\n\n\n3.数组的地址值\n\n扩展:解释一下数组地址值的含义是什么([I@16b98e56)\n[ 表示当前是一个数组,I表示当前数据类型都是int类型的.@表示一个间隔符号(固定格式)\n16b98e56:是数组真正的地址值,用十六进制表示而我们平时会习惯性的把这个整体叫做地址值\n4.数组的遍历遍历指的是取出数字的过程,不要局限理解为打印数据 .关于数组的长度 用数组名.length表示数组的长度,\n5.数组动态初始化\n\n\n6.数组的内存图Java内存分配  \n\n1.只要是new出来的东西,一定在堆里面开辟了一个小空间,如果new了很多次,那么在堆里面有很多小空间,每个小空间中都有各自的存储数据\n两个数组指向同一个空间的内存图\n2.当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了。\n7.数组常见的问题索引越界异常\n8.数组的常见操作求最值,求和,交换数组,打乱数组\n4.方法1.方法的基本认识方法时程序执行中最小的单元\n实际开发中什么时候用到方法?\n重复的代码,具有独立功能的代码可以抽取到方法中.\n方法的好处:提高代码复用性,提高代码的可维护性.\n2.方法调用方法定义后不能直接运行,需要手动调用,该方法成为方法调用\n3.方法的定义格式1.最简单的定义方法\n2.带参数的方法的定义\n\n形参(方法定义中的参数)和实参(方法调用中的参数)\n3.带返回值的方法的定义\n\n格式:\n\n\n4.总结什么时候用到有返回值的方法?\n在调用处要根据方法的结果,去编写另外一段代码\n4.方法小结方法不调用就不执行,方法之间值平级关系,不能互相嵌套定义\n方法的编写顺序和执行顺序无关\nreturn关键字:方法没有返回值:可以省略不写。如果书写，表示结束方法\n​                        方法有返回值:必须要写。表示结束方法和返回结果\n5.方法的重载\n6.输出语句总结\n7.方法的内存传递引用数据类型时,传递的是地址值,形参的改变,会影响实际值的改变\n5.复习1.买飞机票ctrl + alt +M自动抽取方法\n\n\n2.求质数\n\n3.开发验证码将大小写字符放到一个数组中,需要将数字强转为字符类型,放到数组中之后,进行随机索引得到随机字符\n\n\n思考:如果数字随机位置呢?\n4.数组元素的复制\n\n5.评委打分\n\n需要注意红框里面的\n6.数字加密\n将数组中的数字进行反转的操作.\n\n\n红框里面的操作是将数字转化为字符类型,放到数组中的时候便于求出长度 \n7.抢红包格式化代码 ctrl + alt + l\n\n\n8.模拟双色球略\n6.二维数组当我们需要把数据分组管理的时候，就需要用到二维数组\n\n提示:放我们定义数组的时候需要把方括号写到前面\n\n\n \n\n\n\n\n二维数组的内存图\n\n7.面向对象\n1.设计对象并使用类:对对象共同特征的描述\n对象:真实存在的具体东西\n在Java中必须先设计类,才能获取对象\n\n补充注意事项:用来描述一类事物的类专业叫做JavaBean类,在这个类中是不写main方法的,以前我们编写的main方法的类叫做测试类,我们可以在测试类中创建javabean类的对象来进行赋值使用\n2.封装对象代表什么，就得封装对应的数据，并提供数据对应的行为\n人关门:门是自己关的,人只是调用了门的一个关门的方法\n3.this关键字成员变量和局部变量 .如果局部变量里面直接写这个变量会触发就近原则,如果在这个变量前面加上this不会发生这种情况 \n这个关键字的作用就是区别成员变量和局部变量**,this方法的本质就是代表方法调用者的地址值**\n4.构造方法(构造器)\n\n如果我们没写任何一个构造器,那么虚拟机会自动给我们加上一个空参构造器,我们在写代码的时候一般空参构造和有参构造都要写上\n\n\n5.标准JavaBean\n\n快速生成JavaBean的方法:alt + insert 或者IDEA里面下载一个PTG插件\n6.对象内存图两个引用指向同一个对象\n\n\n基本数据类型和引用数据类型\n\n\n7.补充知识8.private关键字\n8.面向对象综合训练1.文字版格斗游戏System.out.printf(&quot;&quot;);\n\n\n\n\n循环不知道要打多少轮所以用while(true),使用break来终止循环,这一点没想清楚\n2.数组练习\n遇到空格就会把空格后面的输入给下面的录入对象\n\n两套体系不能混用,如果先用第一套,再用第二套会导致下面的nextLine接收不到数据 \nreturn 可以返回-1;\n3.字符串1.API和API文档API:应用程序编程接口,简单理解API就是别人已经写好的东西,我们不需要编写,直接使用即可.\n2.字符串1.String概述字符串的内容是不会发生改变的,它的对象在创建后不能发生改变\nString是Java定义好的一个类,定义在Java.long包中,所以使用的时候不需要导包 \n\n\n2.Java比较&#x3D;&#x3D;号比的到底是什么基本数据类型比较的是数据值,引用数据类型比较的是地址值是否相同\n\n\n字符串比较内容:\n\n 只要比较字符串的内容就需要使用String里面的方法\nctrl + alt + t 是包裹代码的快捷键\n\n\n3.遍历字符串\n\nchar类型变量在参与运算的时候计算机自动类型提升为int查询acsii码表 \n\n截取字符串,如果输入一串数字字符串,可以用强转把字符串转换为数字\n\n4.StringBuilder\n可以看做是一个容器,创建之后里面的,内容是可以改变的\n\n\n\n\n5.StringJonier\n\n\n\n\n\n如果全部赋值给一个变量,也可以按照上面这样写\n\n6.总结如果要想给字符交换位置,可以先把他变换为字符数组交换万,再变回字符串.\n4.ArrayList1.集合的基本使用\n\n2.ArrayList类\n3.基本数据类型对应的包装类","slug":"Java笔记","date":"2022-11-21T06:51:32.570Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"521d22a4a6d0170569a691b35603f80b","title":"Javaweb","content":"1.Session（重点）1.session和cookie的区别Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）\nsession是把用户的数据写到用户独占的Session中，服务器端保存（保存重要信息，减少服务器资源浪费）\nSession由服务器创建\n2.使用场景用来保存用户登录信息\n在整个网站中经常会使用的数据，我们将它保存在Session中;\n2.JSP1.什么是JSPJava Server Pages:Java服务器端页面，也和Servlet一样用于动态web技术\n最大的特点：\n写JSP就像是在写html\n区别：\nHTML只给用户提供静态数据\nJSP中可以嵌入JAVA代码，为用户提供动态数据\n2.JSP原理浏览器想服务器发送请求，不管访问什么资源，其实都是在访问servlet！\nJSP最终会被转换成一个java类\nJSP本质上就是一个Servlet类\n在JSP页面中，只要是JAVA代码就会被原封不动的输出，如果是HTML代码会被转换为\nout.write(&quot;&quot;);\n\n这样的格式输出到前端\n3.JSP基础语法JSP注释会在客户端显示，HTML不会\n4.JSP指令3.JavaBeanjavabean有特定的写法：\n必须要有一个无参构造器\n属性必须私有化\n必须有对应的get&#x2F;set方法，一般用来和数据库的字段做映射\n","slug":"Javaweb","date":"2022-11-11T13:53:28.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"8c6c59136f9c0c8c29b87ea646eed9d1","title":"操作系统","content":"3.1内存的基础知识1.什么是内存1.内存是用来存放数据的硬件。程序执行钱需要先放到内存中才能被CPU处理。\n\n\n\n\n3.2.装入的三种方式（完成逻辑地址到物理地址的转换）1.绝对装入在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。绝对装入适用于单道程序环境\n2.静态重定位又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。\n\n\n3.动态重定位又称动态运行时装入。编译、链接后的装入模块的地址都是从o开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。\n\n\n\n\n4.链接的三种方式需要将独立的逻辑地址合并成完整的逻辑地址需要进行链接\n1.静态链接:在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）,之后不再拆开。\n2.装入时动态链接:将各目标模块装入内存时，边装入边链接的链接方式。\n3.运行时动态链接:在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n3.3内存管理的概念\n3.4覆盖与交换1.内存空间扩充技术覆盖技术，交换技术，虚拟存储技术，引入覆盖技术解决程序大小超过物理内存总和问题。\n2.覆盖技术覆盖技术的思想:将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。\n内存中分为一个“固定区”和若干个“覆盖区”。\n需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)\n不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存\n覆盖技术缺点：对用户不透明，增加了用户编程负担，只用于早期操作系统中\n3.交换技术交换（对换）技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度)。\n\n4两者的区别覆盖技术是在一个进程中进行而交换技术是在多个进程中 \n3.5内存空间的分配和回收1.单一连续分配在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。\n内存中只能有一道用户程序，用户程序独占整个用户区空间。\n优点:实现简单;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护\n缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。（分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”）\n\n\n2.固定分区分配20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。\n分区大小相等:缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合\n分区大小不等：增加灵活性，可以满足不同大小的进程需求。\n操作系统需要建立一个数据结构――分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。\n当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。\n优点：实现简单，无外部碎片\n缺点：当用户程序太大时，可能所有分区都不能同时满足需求，此时不得不采用覆盖技术来解决，这又降低了性能，还有会产生内部碎片，内存利用率低\n3.动态分区分配动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。\n1.系统要用什么样的数据结构记录内存的使用情况?\n\n2.当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?\n把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。\n3.如何进行分区的分配与回收操作?\n略\n动态分区分配没有内部碎片，但是有外部碎片\n1.内部碎片分配给某进程的内存区域中，如果有些部分没有用上。\n2.外部碎片是指内存中的某些空闲分区由于太小而难以利用。\n3.紧凑如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑来解决外部碎片\n4.总结\n3.6动态分区分配算法1.首次适应算法算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。\n如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。\n2.最佳适应算法算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区。\n如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。\n缺点：每次都选最小的分区进行分配，会留下来越来越多很小的，难以利用的内存块，因此这种方法会产生很多外部碎片。\n3.最坏适应算法（最大适应算法）算法思想:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。\n如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。\n\n\n4.邻近适应算法算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。\n如何实现:空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。\n\n\n5.总结\n\n3.7内存管理1.分页存储管理\n\n页号&#x3D;逻辑地址&#x2F;页面长度（去除法整数部分）\n页内偏移量&#x3D;逻辑地址&#x2F;页面长度（去除法余数部分）\n2.逻辑地址结构：\n\n\n\n3.页表为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 页表记录进程页面和实际存放的内存块之间的对应关系。\n3.8基本地址变换机构基本地址转换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。\n\n\n在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。\n总结\n3.9具有快表的地址变换机构1.局部性原理1.时间局部性如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环)\n2.空间局部性一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的)\n2.快表快表，又称联想寄存器(TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。\n1.地址变换过程\n\n4.0两级页表1.单级页表存在的问题\n2.两级页表的原理、地址结构4.1文件存储管理\n4.2文件的基本操作1.打开文件\n2.关闭文件进程使用文件后要关闭文件，\n1.将进程打开文件表相应表项删除。\n2.回收分配给文件的内存空间等资源\n3.系统打开文件表的打开计数器count减一，count等于零则删除对应表项。\n3.读文件\n4.写文件\n5.总结\n4.3文件共享注意：多个用户共享统一个文件，意味着系统只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。\n1.基于索引节点的共享方式（硬链接）索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。\n\n2.基于符号连的共享方式（软链接）\n4.4文件保护1.口令保护\n2.加密保护\n3.访问控制\n4.总结\n4.5文件系统的层次结构\n\n4.6磁盘的结构1.磁盘，磁道，扇区磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。\n\n2.怎么在磁盘中读&#x2F;写数据\n3.盘面，柱面\n4.磁盘的物理地址\n5.磁盘的分类活动头磁盘：磁头可以移动。磁臂可以来回伸缩带动磁头定位磁道。\n\n\n固定头磁盘：磁头不可以移动，每个磁道有一个磁头。\n\n\n6.总结\n4.7磁盘调度算法1.磁盘读写操作需要的时间1.寻找时间在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间。\n\n\n2.延迟时间通过旋转磁盘，使磁头定位到目标扇区所需要的时间。\n\n\n3.传输时间从磁盘读出或向磁盘写入数据所经历的时间。\n\n\n4.总结延迟时间和传输时间都和磁盘转速有关，都是线性相关，转速是磁盘固有属性，因此操作系统无法优化这两个时间。\n2.算法1.先来先服务算法（FCFS）根据进程请求访问磁盘的先后顺序进行调度。\n\n\n优点：公平，如果请求访问的磁道比较集中的话，算法性能还算过得去。\n缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。\n2.最短寻找时间优先（SSTF）SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)\n\n\n3.扫描算法（SCAN）\n\n4.LOOK调度算法\n\n5.循环扫描算法（C-SCAN）\n\n6.C-LOOK调度算法\n\n3.总结\n4.8减少延迟时间的方法1.交替编号\n\n若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。\n具体做法是让编号相邻的扇区在物理上不相邻。\n2.磁盘地址结构的设计物理地址结构是柱面号，盘面号，扇区号。这种方式，在读取地址连续的磁盘块的时候，可以减少磁头移动消耗的时间。\n3.错位命名让相邻盘面的扇区编号错位。\n\n4.9磁盘的管理1.磁盘初始化\n2.引导块计算机开机时需要进行一系列初始化工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。\nROM：初始化程序可以放在ROM中（）只读存储器，ROM中的数据在出厂的时候就写入了，并且以后不能修改。ROM一般出厂就集成在了主板上。\n现在ROM中只是存放很小的自举装入程序，完整的程序放在磁盘的启动快中，启动快位于磁盘的固定位置。\n拥有启动分区的磁盘统称为启动磁盘（C盘）\n3.坏块管理\n\n5.0 I-O设备概念1.I-O控制器的功能接受和识别CPU发出的指令，向CPU报告设备的状态，数据交换，地址识别。\n2.I&#x2F;O控制器的组成\n\n3.总结\n5.1I&#x2F;O控制方式","slug":"操作系统","date":"2022-11-11T13:53:28.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"3.存储系统1.双端口RAM和多模块存储器1.多体并行存储器1.高位交叉编址\n2.低位交叉编址\n实际上采用了“流水线”的方式并行存取，当存储周期为T时，存取时间为r时，为了使流水线不间断，，应该保证模块数m&gt;&#x3D;T&#x2F;r，如果m小于T&#x2F;r，则cpu需要等待r。\n若给定一个地址x，应该用它的体号来判断它属于第几个存储体。\n3.多模块存储器1.多体并行存储器\n2.单体多字存储器\n每次直接读一整行字，灵活性没有多体高，会读入一些没有意义的数据。但是速度都差不多，高位交叉的多体存储器相当于扩单纯的扩容，低位交叉的多体存储器相当于双通道，可以使吞吐量翻倍在连续访问时，\n2.双端口RAM\n2.Cache1.Cache工作原理cache被集成在CPU内部，cache用SRAM实现，速度快，成本高。\nRAM可分为静态存储器（Static Random Access Memory,SRAM）和动态存储器（Dynamic Random Access Memory）。SRAM中的存储单元相当于一个锁存器，只有0，1两个稳态；DRAM则是利用电容存储电荷来保存0和1两种状态，因此需要定时对其进行刷新，否则随着时间的推移，电容其中存储的电荷将逐渐消失。\nSRAM：读写速度快，生产成本高，多用于容量较小的高速缓冲存储器。\nDRAM：读写速度较慢，集成度高，生产成本低，多用于容量较大的主存储器。\n2.局部性原理1.空间局部性在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是邻近的（数组元素，顺序执行的指令代码）\n2.时间局部性在最近的未来要用到的信息，很可能是现在正在使用的信息（循环结构的指令代码）\n基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放到cache中\n3.性能分析命中率：CPU想要访问的信息已经在Cache中的比率\n设tc为访问一次Cache所需时间,tm为访问一次主存所需时间\nCache—主存系统的平均访问时间t为\nt &#x3D; Htc+(1 一H)(tc + tm)\n主存和Cache是以块为单位进行数据交换。\n\n3.Cache和主存的映射方式1.全相联映射主存块可以放在Cache任意位置（Cache块和主存块大小相等）\n\nCpu访问主存地址\n\n\n2.直接映射每个主存块只能放到一个特定的位置:Cache块号&#x3D;主存块号% Cache总块数\n若cache总块数&#x3D;2^n,则主存块号末尾n位直接反映它在Cache中的位置，将主存块号的其余位作为标记即可\n\n\n3.组相联映射Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置，组号&#x3D;主存块号%分组数\n\n\n4.替换算法1.随机算法（RAND）\n\n2.先进先出算法（FIFO）\n\n3.近期最少使用算法（LRU）\n4.最不经常使用算法（LFU）\n5.总结\n5.Cache写策略（确保主存中母本一致性）1.写命中1.写回法Cache设置脏位，当数据被修改是，脏位变成1。当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。减少了访存次数，但存在数据不一致的隐患。\n2.全写法当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲(write buffer)，访问主存次数增加，速度变慢，但更能保证数据一致性。\n使用写缓冲。CPU写的速度很快，若写操作不频繁，则效果很好。减写操作很频繁手感熊会因为写缓冲饱和发生阻塞。（写缓冲是SRAM实现的FIFO队列）\n2.写不命中1.写分配法写分配法(write-allocate)———当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配写回法使用。\n2.非写分配法非写分配法(not-write-allocate)—当CPU对Cache写不命中时只写入主存，不调入Cache。搭配全写法使用。\n3多级cache现代计算机常采用多级cache\n离CPU越近的速度越快，容量越小，离CPU越远的速度越慢，容量越大\n6.页式存储器1.定义一个程序（进程），在逻辑上被分为若干个大小相等的“页面”，页面大小和块大小相同，每个页面可以放入不同的主存块中。\n2.虚地址和实地址逻辑地址（虚地址）：程序员视角看到的地址，逻辑页号+页内地址\n物理地址（实地址）：实际在主存中的地址，主存块号+页内地址\nCPU执行的机器指令中，使用的是逻辑地址，因此需要页表将逻辑地址转变为物理地址，\n页表的作用是为了记录每个逻辑页面存放到那个主存块当中\n\n\n3.地址变换过程\n增加TLB\n\n4.注意快表中存储的是页表项的副本，Cache中存储的是主存块的副本。\n7.虚拟存储器1.页面虚拟存储器定义：把程序拆分成大小相等的页面\n\n有效位:这个页面是否已调入主存\n脏位:这个页面是否被修改过\n引用位:用于“页面置换算法”，比如，可以用来统计这个页面被访问过多少次\n物理页:即主存块号\n磁盘地址:即这个页面的数据在磁盘中的存放位置\n2.存储器层次化结构主存—辅存：实现虚拟存储系统，解决了主存容量不够的问题。\nCache—主存：解决了主存和CPU速度不匹配的问题。\n3.段式虚拟存储器定义：把程序按照功能模块拆分\n4.指令系统1.回忆计算机工作过程\n\n2.指令格式1.指令的定义是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。\n2.指令格式一条指令就是一组有意义的二进制代码，一条指令通常要包括操作码字段和地址码字段。 \n1.零地址指令（OP）不需要操作数，如空操作数，停机，关中断等指令，堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶\n2.一地址指令（OP + A1）\n\n\n\n3.按照指令长度分类定长操作码：指令系统中所有指令的操作码长度都相同，控制器的译码电路设计简单,但灵活性较低\n可变长操作码：指令系统中各指令的操作码长度可变，控制器的译码电路设计复杂,但灵活性较高\n4.按照操作类型分类\n\n3.总结\n\n4.扩展操作码定长指令字结构 + 可变长操作码（不同地址数的指令使用不同长度的操作码）\n通常情况下，对使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。\n\n\n5.指令寻址1.顺序寻址(PC)+“1”——&gt;PC\n2.转移寻址\n\n3.总结\n\n6.数据寻址5.中央处理器计算机工作过程：首先PC将指令给到MAR，MAR进入储存体再到MDR，MDR给到IR，IR将操作码部分给到CU，分析指令，再将操作码送到CU，分析完指令，将地址码送到MAR，，然后到存储体中找到相应的数据，给到MDR，，然后通过数据通路送到ACC。 \n1.CPU基本结构和功能1.指令控制完成取指令，分析指令，和执行指令的操作，即程序的顺序控制。\n2.操作控制一条指令的功能往往是由若干操作信号的组合来实现的。CPu管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。\n3.时间控制对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。\n4.数据加工对数据进行算术和逻辑运算\n5.中断处理对计算机运行过程中出现的异常情况和特殊请求进行处理。\n6.运算器对数据进行加工\n7.控制器协调并控制计算机各部件执行程序的指令序列,基本功能包括取指令、分析指令、执行指令\n2.运算器的基本结构\n3.控制器的基本结构\n4.CPU基本结构\n5.指令的执行过程1.指令周期CPU从主存中每取出并执一条指令所需的全部时间。\n\n\n\n\n\n\n6.数据通路的功能内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线;系统总线是指同一台计算机系统的各部件，如CPU、内存、通道和各类I&#x2F;o接口间互相连接的总线。\n1.寄存器之间的数据传送\n2.主存和CPU之间的数据传送\n3.执行算术或逻辑运算MDR传入IR，MDR里面也会保存一份。也可以直接从MDR传送到MAR。\n\n\n\n\n\n\n\n7.专用数据通路\n\n运算器ALU不是寄存器，数据会被放到累加器ACC中，\n\n\n\n\n\n8.控制器的设计1.硬布线控制器\n\n\n2.硬布线控制器的设计\n\n\n1–&gt;R是指向主存发出读信号。\n3.微程序控制器的基本原理（考察频率较高）1.微程序硬布线控制器：微操作控制信号有组合逻辑电路根据当前的指令码，状态和时序（时序信息包括机器周期和节拍），即使产生。\n程序：是指令组成的。\n微程序：由微指令序列组成，每一种指令对应一个微程序。\n指令是对程序执行步骤的描述，微指令是对指令执行步骤的描述\n指令是对微指令功能的“封装”\n一条微指令可能包含多个微命令，\n微命令和微操作是一一对应的。\n2.微程序控制器基本结构\n3.工作原理\n\n4.总结\n4.微指令的设计1.微指令的格式\n\n1.水平型微指令\n一条微指令可以定义多个可并行的微命令，微程序段，执行速度很快。但是微指令较长，编写微程序比较麻烦\n\n2.垂直型微指令\n一条微指令只能定义一个微命令，由微操作码字段规定具体功能。\n\n3.混合型微指令\n在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写;微程序也不长，执行速度加快。\n","slug":"计算机组成原理","date":"2022-11-11T13:33:06.356Z","categories_index":"","tags_index":"","author_index":"Aurora"}]