{"title":"操作系统","uid":"8c6c59136f9c0c8c29b87ea646eed9d1","slug":"操作系统","date":"2022-11-11T13:53:28.000Z","updated":"2022-11-18T14:48:30.435Z","comments":true,"path":"api/articles/操作系统.json","keywords":null,"cover":[],"content":"<h2 id=\"3-1内存的基础知识\"><a href=\"#3-1内存的基础知识\" class=\"headerlink\" title=\"3.1内存的基础知识\"></a>3.1内存的基础知识</h2><h4 id=\"1-什么是内存\"><a href=\"#1-什么是内存\" class=\"headerlink\" title=\"1.什么是内存\"></a>1.什么是内存</h4><p>1.内存是用来存放数据的硬件。程序执行钱需要先放到内存中才能被CPU处理。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221003081920244.png\" style=\"zoom: 50%;\">\n\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221003082216392.png\" alt=\"image-20221003082216392\" style=\"zoom:33%;\">\n\n<h2 id=\"3-2-装入的三种方式（完成逻辑地址到物理地址的转换）\"><a href=\"#3-2-装入的三种方式（完成逻辑地址到物理地址的转换）\" class=\"headerlink\" title=\"3.2.装入的三种方式（完成逻辑地址到物理地址的转换）\"></a>3.2.装入的三种方式（完成逻辑地址到物理地址的转换）</h2><h4 id=\"1-绝对装入\"><a href=\"#1-绝对装入\" class=\"headerlink\" title=\"1.绝对装入\"></a>1.绝对装入</h4><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。绝对装入适用于单道程序环境</p>\n<h4 id=\"2-静态重定位\"><a href=\"#2-静态重定位\" class=\"headerlink\" title=\"2.静态重定位\"></a>2.静态重定位</h4><p>又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221003083529134.png\" alt=\"image-20221003083529134\" style=\"zoom:50%;\">\n\n<h4 id=\"3-动态重定位\"><a href=\"#3-动态重定位\" class=\"headerlink\" title=\"3.动态重定位\"></a>3.动态重定位</h4><p>又称动态运行时装入。编译、链接后的装入模块的地址都是从o开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221003083745176.png\" alt=\"image-20221003083745176\" style=\"zoom: 50%;\">\n\n\n\n<h4 id=\"4-链接的三种方式\"><a href=\"#4-链接的三种方式\" class=\"headerlink\" title=\"4.链接的三种方式\"></a>4.链接的三种方式</h4><p>需要将独立的逻辑地址合并成完整的逻辑地址需要进行链接</p>\n<p>1.静态链接:在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）,之后不再拆开。</p>\n<p>2.装入时动态链接:将各目标模块装入内存时，边装入边链接的链接方式。</p>\n<p>3.运行时动态链接:在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p>\n<h2 id=\"3-3内存管理的概念\"><a href=\"#3-3内存管理的概念\" class=\"headerlink\" title=\"3.3内存管理的概念\"></a>3.3内存管理的概念</h2><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221003085345425.png\" alt=\"image-20221003085345425\"></p>\n<h2 id=\"3-4覆盖与交换\"><a href=\"#3-4覆盖与交换\" class=\"headerlink\" title=\"3.4覆盖与交换\"></a>3.4覆盖与交换</h2><h3 id=\"1-内存空间扩充技术\"><a href=\"#1-内存空间扩充技术\" class=\"headerlink\" title=\"1.内存空间扩充技术\"></a>1.内存空间扩充技术</h3><p>覆盖技术，交换技术，虚拟存储技术，引入覆盖技术解决程序大小超过物理内存总和问题。</p>\n<h3 id=\"2-覆盖技术\"><a href=\"#2-覆盖技术\" class=\"headerlink\" title=\"2.覆盖技术\"></a>2.覆盖技术</h3><p>覆盖技术的思想:将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。</p>\n<p>内存中分为一个“固定区”和若干个“覆盖区”。</p>\n<p>需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)</p>\n<p>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</p>\n<p>覆盖技术缺点：对用户不透明，增加了用户编程负担，只用于早期操作系统中</p>\n<h3 id=\"3-交换技术\"><a href=\"#3-交换技术\" class=\"headerlink\" title=\"3.交换技术\"></a>3.交换技术</h3><p>交换（对换）技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度)。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221003090409343.png\" alt=\"image-20221003090409343\"></p>\n<h3 id=\"4两者的区别\"><a href=\"#4两者的区别\" class=\"headerlink\" title=\"4两者的区别\"></a>4两者的区别</h3><p>覆盖技术是在一个进程中进行而交换技术是在多个进程中 </p>\n<h2 id=\"3-5内存空间的分配和回收\"><a href=\"#3-5内存空间的分配和回收\" class=\"headerlink\" title=\"3.5内存空间的分配和回收\"></a>3.5内存空间的分配和回收</h2><h3 id=\"1-单一连续分配\"><a href=\"#1-单一连续分配\" class=\"headerlink\" title=\"1.单一连续分配\"></a>1.单一连续分配</h3><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。</p>\n<p>内存中只能有一道用户程序，用户程序独占整个用户区空间。</p>\n<p>优点:实现简单;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护</p>\n<p>缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。（分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”）</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221004141725172.png\" alt=\"image-20221004141725172\" style=\"zoom:33%;\">\n\n<h3 id=\"2-固定分区分配\"><a href=\"#2-固定分区分配\" class=\"headerlink\" title=\"2.固定分区分配\"></a>2.固定分区分配</h3><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p>\n<p>分区大小相等:缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合</p>\n<p>分区大小不等：增加灵活性，可以满足不同大小的进程需求。</p>\n<p>操作系统需要建立一个数据结构――分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。</p>\n<p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p>\n<p>优点：实现简单，无外部碎片</p>\n<p>缺点：当用户程序太大时，可能所有分区都不能同时满足需求，此时不得不采用覆盖技术来解决，这又降低了性能，还有会产生内部碎片，内存利用率低</p>\n<h3 id=\"3-动态分区分配\"><a href=\"#3-动态分区分配\" class=\"headerlink\" title=\"3.动态分区分配\"></a>3.动态分区分配</h3><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p>\n<p>1.系统要用什么样的数据结构记录内存的使用情况?</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221004144038377.png\" alt=\"image-20221004144038377\"></p>\n<p>2.当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</p>\n<p>把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p>\n<p>3.如何进行分区的分配与回收操作?</p>\n<p>略</p>\n<p>动态分区分配没有内部碎片，但是有外部碎片</p>\n<h4 id=\"1-内部碎片\"><a href=\"#1-内部碎片\" class=\"headerlink\" title=\"1.内部碎片\"></a>1.内部碎片</h4><p>分配给某进程的内存区域中，如果有些部分没有用上。</p>\n<h4 id=\"2-外部碎片\"><a href=\"#2-外部碎片\" class=\"headerlink\" title=\"2.外部碎片\"></a>2.外部碎片</h4><p>是指内存中的某些空闲分区由于太小而难以利用。</p>\n<h4 id=\"3-紧凑\"><a href=\"#3-紧凑\" class=\"headerlink\" title=\"3.紧凑\"></a>3.紧凑</h4><p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑来解决外部碎片</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221004145747829.png\" alt=\"image-20221004145747829\"></p>\n<h2 id=\"3-6动态分区分配算法\"><a href=\"#3-6动态分区分配算法\" class=\"headerlink\" title=\"3.6动态分区分配算法\"></a>3.6动态分区分配算法</h2><h3 id=\"1-首次适应算法\"><a href=\"#1-首次适应算法\" class=\"headerlink\" title=\"1.首次适应算法\"></a>1.首次适应算法</h3><p><em>算法思想</em>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p>\n<p><em>如何实现</em>：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>\n<h3 id=\"2-最佳适应算法\"><a href=\"#2-最佳适应算法\" class=\"headerlink\" title=\"2.最佳适应算法\"></a>2.最佳适应算法</h3><p><em>算法思想</em>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用<em>更小的空闲区</em>。</p>\n<p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>\n<p>缺点：每次都选最小的分区进行分配，会留下来越来越多很小的，难以利用的内存块，因此这种方法会产生很多外部碎片。</p>\n<h3 id=\"3-最坏适应算法（最大适应算法）\"><a href=\"#3-最坏适应算法（最大适应算法）\" class=\"headerlink\" title=\"3.最坏适应算法（最大适应算法）\"></a>3.最坏适应算法（最大适应算法）</h3><p>算法思想:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，<em>可以在每次分配时优先使用最大的连续空闲区</em>，这样分配后剩余的空闲区就不会太小，更方便使用。</p>\n<p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221010085244436.png\" alt=\"image-20221010085244436\" style=\"zoom:50%;\">\n\n<h3 id=\"4-邻近适应算法\"><a href=\"#4-邻近适应算法\" class=\"headerlink\" title=\"4.邻近适应算法\"></a>4.邻近适应算法</h3><p>算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>\n<p>如何实现:空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221010085926160.png\" alt=\"image-20221010085926160\" style=\"zoom:50%;\">\n\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221010090053926.png\" alt=\"image-20221010090053926\" style=\"zoom:50%;\">\n\n<h2 id=\"3-7内存管理\"><a href=\"#3-7内存管理\" class=\"headerlink\" title=\"3.7内存管理\"></a>3.7内存管理</h2><h3 id=\"1-分页存储管理\"><a href=\"#1-分页存储管理\" class=\"headerlink\" title=\"1.分页存储管理\"></a>1.分页存储管理</h3><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221010090909206.png\" alt=\"image-20221010090909206\" style=\"zoom:50%;\">\n\n<p>页号&#x3D;逻辑地址&#x2F;页面长度（去除法整数部分）</p>\n<p>页内偏移量&#x3D;逻辑地址&#x2F;页面长度（去除法余数部分）</p>\n<h3 id=\"2-逻辑地址结构：\"><a href=\"#2-逻辑地址结构：\" class=\"headerlink\" title=\"2.逻辑地址结构：\"></a>2.逻辑地址结构：</h3><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221010092930059.png\" alt=\"image-20221010092930059\" style=\"zoom:50%;\">\n\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/files\\Typora\\photo\\image-20221010092950662.png\" alt=\"image-20221010092950662\" style=\"zoom:50%;\">\n\n<h3 id=\"3-页表\"><a href=\"#3-页表\" class=\"headerlink\" title=\"3.页表\"></a>3.页表</h3><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 页表记录进程页面和实际存放的内存块之间的对应关系。<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221010094717580.png\" alt=\"image-20221010094717580\"></p>\n<h2 id=\"3-8基本地址变换机构\"><a href=\"#3-8基本地址变换机构\" class=\"headerlink\" title=\"3.8基本地址变换机构\"></a>3.8基本地址变换机构</h2><p>基本地址转换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221020102758166.png\" alt=\"image-20221020102758166\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/files\\Typora\\photo\\image-20221020104529251.png\" alt=\"image-20221020104529251\"></p>\n<p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221020105203279.png\" alt=\"image-20221020105203279\"></p>\n<h2 id=\"3-9具有快表的地址变换机构\"><a href=\"#3-9具有快表的地址变换机构\" class=\"headerlink\" title=\"3.9具有快表的地址变换机构\"></a>3.9具有快表的地址变换机构</h2><h3 id=\"1-局部性原理\"><a href=\"#1-局部性原理\" class=\"headerlink\" title=\"1.局部性原理\"></a>1.局部性原理</h3><h4 id=\"1-时间局部性\"><a href=\"#1-时间局部性\" class=\"headerlink\" title=\"1.时间局部性\"></a>1.时间局部性</h4><p>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环)</p>\n<h4 id=\"2-空间局部性\"><a href=\"#2-空间局部性\" class=\"headerlink\" title=\"2.空间局部性\"></a>2.空间局部性</h4><p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的)</p>\n<h3 id=\"2-快表\"><a href=\"#2-快表\" class=\"headerlink\" title=\"2.快表\"></a>2.快表</h3><p>快表，又称联想寄存器(TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p>\n<h4 id=\"1-地址变换过程\"><a href=\"#1-地址变换过程\" class=\"headerlink\" title=\"1.地址变换过程\"></a>1.地址变换过程</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221020151352944.png\" alt=\"image-20221020151352944\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/files\\Typora\\photo\\image-20221020151620921.png\" alt=\"image-20221020151620921\"></p>\n<h2 id=\"4-0两级页表\"><a href=\"#4-0两级页表\" class=\"headerlink\" title=\"4.0两级页表\"></a>4.0两级页表</h2><h4 id=\"1-单级页表存在的问题\"><a href=\"#1-单级页表存在的问题\" class=\"headerlink\" title=\"1.单级页表存在的问题\"></a>1.单级页表存在的问题</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221020154353196.png\" alt=\"image-20221020154353196\"></p>\n<h4 id=\"2-两级页表的原理、地址结构\"><a href=\"#2-两级页表的原理、地址结构\" class=\"headerlink\" title=\"2.两级页表的原理、地址结构\"></a>2.两级页表的原理、地址结构</h4><h2 id=\"4-1文件存储管理\"><a href=\"#4-1文件存储管理\" class=\"headerlink\" title=\"4.1文件存储管理\"></a>4.1文件存储管理</h2><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221111122234498.png\" alt=\"image-20221111122234498\"></p>\n<h2 id=\"4-2文件的基本操作\"><a href=\"#4-2文件的基本操作\" class=\"headerlink\" title=\"4.2文件的基本操作\"></a>4.2文件的基本操作</h2><h4 id=\"1-打开文件\"><a href=\"#1-打开文件\" class=\"headerlink\" title=\"1.打开文件\"></a>1.打开文件</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221112130214192.png\" alt=\"image-20221112130214192\"></p>\n<h4 id=\"2-关闭文件\"><a href=\"#2-关闭文件\" class=\"headerlink\" title=\"2.关闭文件\"></a>2.关闭文件</h4><p>进程使用文件后要关闭文件，</p>\n<p>1.将进程打开文件表相应表项删除。</p>\n<p>2.回收分配给文件的内存空间等资源</p>\n<p>3.系统打开文件表的打开计数器count减一，count等于零则删除对应表项。</p>\n<h4 id=\"3-读文件\"><a href=\"#3-读文件\" class=\"headerlink\" title=\"3.读文件\"></a>3.读文件</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113174239073.png\" alt=\"image-20221113174239073\"></p>\n<h4 id=\"4-写文件\"><a href=\"#4-写文件\" class=\"headerlink\" title=\"4.写文件\"></a>4.写文件</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113174320095.png\" alt=\"image-20221113174320095\"></p>\n<h4 id=\"5-总结-1\"><a href=\"#5-总结-1\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113174423072.png\" alt=\"image-20221113174423072\"></p>\n<h2 id=\"4-3文件共享\"><a href=\"#4-3文件共享\" class=\"headerlink\" title=\"4.3文件共享\"></a>4.3文件共享</h2><p>注意：多个用户共享统一个文件，意味着系统只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</p>\n<h3 id=\"1-基于索引节点的共享方式（硬链接）\"><a href=\"#1-基于索引节点的共享方式（硬链接）\" class=\"headerlink\" title=\"1.基于索引节点的共享方式（硬链接）\"></a>1.基于索引节点的共享方式（硬链接）</h3><p>索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113174819791.png\" alt=\"image-20221113174819791\"></p>\n<h3 id=\"2-基于符号连的共享方式（软链接）\"><a href=\"#2-基于符号连的共享方式（软链接）\" class=\"headerlink\" title=\"2.基于符号连的共享方式（软链接）\"></a>2.基于符号连的共享方式（软链接）</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113174929918.png\" alt=\"image-20221113174929918\"></p>\n<h2 id=\"4-4文件保护\"><a href=\"#4-4文件保护\" class=\"headerlink\" title=\"4.4文件保护\"></a>4.4文件保护</h2><h3 id=\"1-口令保护\"><a href=\"#1-口令保护\" class=\"headerlink\" title=\"1.口令保护\"></a>1.口令保护</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113175031473.png\" alt=\"image-20221113175031473\"></p>\n<h3 id=\"2-加密保护\"><a href=\"#2-加密保护\" class=\"headerlink\" title=\"2.加密保护\"></a>2.加密保护</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113175108939.png\" alt=\"image-20221113175108939\"></p>\n<h3 id=\"3-访问控制\"><a href=\"#3-访问控制\" class=\"headerlink\" title=\"3.访问控制\"></a>3.访问控制</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113175210657.png\" alt=\"image-20221113175210657\"></p>\n<h3 id=\"4-总结-1\"><a href=\"#4-总结-1\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113175240455.png\" alt=\"image-20221113175240455\"></p>\n<h2 id=\"4-5文件系统的层次结构\"><a href=\"#4-5文件系统的层次结构\" class=\"headerlink\" title=\"4.5文件系统的层次结构\"></a>4.5文件系统的层次结构</h2><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113175500829.png\" alt=\"image-20221113175500829\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113175542847.png\" alt=\"image-20221113175542847\"></p>\n<h2 id=\"4-6磁盘的结构\"><a href=\"#4-6磁盘的结构\" class=\"headerlink\" title=\"4.6磁盘的结构\"></a>4.6磁盘的结构</h2><h3 id=\"1-磁盘，磁道，扇区\"><a href=\"#1-磁盘，磁道，扇区\" class=\"headerlink\" title=\"1.磁盘，磁道，扇区\"></a>1.磁盘，磁道，扇区</h3><p>磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113180254144.png\" alt=\"image-20221113180254144\"></p>\n<h3 id=\"2-怎么在磁盘中读-x2F-写数据\"><a href=\"#2-怎么在磁盘中读-x2F-写数据\" class=\"headerlink\" title=\"2.怎么在磁盘中读&#x2F;写数据\"></a>2.怎么在磁盘中读&#x2F;写数据</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113180535594.png\" alt=\"image-20221113180535594\"></p>\n<h3 id=\"3-盘面，柱面\"><a href=\"#3-盘面，柱面\" class=\"headerlink\" title=\"3.盘面，柱面\"></a>3.盘面，柱面</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221113181041530.png\" alt=\"image-20221113181041530\"></p>\n<h3 id=\"4-磁盘的物理地址\"><a href=\"#4-磁盘的物理地址\" class=\"headerlink\" title=\"4.磁盘的物理地址\"></a>4.磁盘的物理地址</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116114730577.png\" alt=\"image-20221116114730577\"></p>\n<h3 id=\"5-磁盘的分类\"><a href=\"#5-磁盘的分类\" class=\"headerlink\" title=\"5.磁盘的分类\"></a>5.磁盘的分类</h3><p>活动头磁盘：磁头可以移动。磁臂可以来回伸缩带动磁头定位磁道。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116114932110.png\" alt=\"image-20221116114932110\" style=\"zoom:33%;\">\n\n<p>固定头磁盘：磁头不可以移动，每个磁道有一个磁头。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116115015485.png\" alt=\"image-20221116115015485\" style=\"zoom:33%;\">\n\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116115048783.png\" alt=\"image-20221116115048783\"></p>\n<h2 id=\"4-7磁盘调度算法\"><a href=\"#4-7磁盘调度算法\" class=\"headerlink\" title=\"4.7磁盘调度算法\"></a>4.7磁盘调度算法</h2><h3 id=\"1-磁盘读写操作需要的时间\"><a href=\"#1-磁盘读写操作需要的时间\" class=\"headerlink\" title=\"1.磁盘读写操作需要的时间\"></a>1.磁盘读写操作需要的时间</h3><h4 id=\"1-寻找时间\"><a href=\"#1-寻找时间\" class=\"headerlink\" title=\"1.寻找时间\"></a>1.寻找时间</h4><p>在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116115423117.png\" alt=\"image-20221116115423117\" style=\"zoom:50%;\">\n\n<h4 id=\"2-延迟时间\"><a href=\"#2-延迟时间\" class=\"headerlink\" title=\"2.延迟时间\"></a>2.延迟时间</h4><p>通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116115550426.png\" alt=\"image-20221116115550426\" style=\"zoom:50%;\">\n\n<h4 id=\"3-传输时间\"><a href=\"#3-传输时间\" class=\"headerlink\" title=\"3.传输时间\"></a>3.传输时间</h4><p>从磁盘读出或向磁盘写入数据所经历的时间。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116115655931.png\" alt=\"image-20221116115655931\" style=\"zoom:50%;\">\n\n<h4 id=\"4-总结-2\"><a href=\"#4-总结-2\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h4><p>延迟时间和传输时间都和磁盘转速有关，都是线性相关，转速是磁盘固有属性，因此操作系统无法优化这两个时间。</p>\n<h3 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2.算法\"></a>2.算法</h3><h4 id=\"1-先来先服务算法（FCFS）\"><a href=\"#1-先来先服务算法（FCFS）\" class=\"headerlink\" title=\"1.先来先服务算法（FCFS）\"></a>1.先来先服务算法（FCFS）</h4><p>根据进程请求访问磁盘的先后顺序进行调度。</p>\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116115941782.png\" alt=\"image-20221116115941782\" style=\"zoom:50%;\">\n\n<p>优点：公平，如果请求访问的磁道比较集中的话，算法性能还算过得去。</p>\n<p>缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</p>\n<h4 id=\"2-最短寻找时间优先（SSTF）\"><a href=\"#2-最短寻找时间优先（SSTF）\" class=\"headerlink\" title=\"2.最短寻找时间优先（SSTF）\"></a>2.最短寻找时间优先（SSTF）</h4><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120212363.png\" alt=\"image-20221116120212363\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120230901.png\" alt=\"image-20221116120230901\"></p>\n<h4 id=\"3-扫描算法（SCAN）\"><a href=\"#3-扫描算法（SCAN）\" class=\"headerlink\" title=\"3.扫描算法（SCAN）\"></a>3.扫描算法（SCAN）</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120321879.png\" alt=\"image-20221116120321879\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120348112.png\" alt=\"image-20221116120348112\"></p>\n<h4 id=\"4-LOOK调度算法\"><a href=\"#4-LOOK调度算法\" class=\"headerlink\" title=\"4.LOOK调度算法\"></a>4.LOOK调度算法</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120455505.png\" alt=\"image-20221116120455505\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120515146.png\" alt=\"image-20221116120515146\"></p>\n<h4 id=\"5-循环扫描算法（C-SCAN）\"><a href=\"#5-循环扫描算法（C-SCAN）\" class=\"headerlink\" title=\"5.循环扫描算法（C-SCAN）\"></a>5.循环扫描算法（C-SCAN）</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120612910.png\" alt=\"image-20221116120612910\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120639610.png\" alt=\"image-20221116120639610\"></p>\n<h4 id=\"6-C-LOOK调度算法\"><a href=\"#6-C-LOOK调度算法\" class=\"headerlink\" title=\"6.C-LOOK调度算法\"></a>6.C-LOOK调度算法</h4><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120704110.png\" alt=\"image-20221116120704110\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120718252.png\" alt=\"image-20221116120718252\"></p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116120748596.png\" alt=\"image-20221116120748596\"></p>\n<h2 id=\"4-8减少延迟时间的方法\"><a href=\"#4-8减少延迟时间的方法\" class=\"headerlink\" title=\"4.8减少延迟时间的方法\"></a>4.8减少延迟时间的方法</h2><h3 id=\"1-交替编号\"><a href=\"#1-交替编号\" class=\"headerlink\" title=\"1.交替编号\"></a>1.交替编号</h3><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116155246392.png\" alt=\"image-20221116155246392\" style=\"zoom:33%;\">\n\n<p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p>\n<p>具体做法是让编号相邻的扇区在物理上不相邻。</p>\n<h3 id=\"2-磁盘地址结构的设计\"><a href=\"#2-磁盘地址结构的设计\" class=\"headerlink\" title=\"2.磁盘地址结构的设计\"></a>2.磁盘地址结构的设计</h3><p>物理地址结构是柱面号，盘面号，扇区号。这种方式，在读取地址连续的磁盘块的时候，可以减少磁头移动消耗的时间。</p>\n<h3 id=\"3-错位命名\"><a href=\"#3-错位命名\" class=\"headerlink\" title=\"3.错位命名\"></a>3.错位命名</h3><p>让相邻盘面的扇区编号错位。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116160645753.png\" alt=\"image-20221116160645753\"></p>\n<h2 id=\"4-9磁盘的管理\"><a href=\"#4-9磁盘的管理\" class=\"headerlink\" title=\"4.9磁盘的管理\"></a>4.9磁盘的管理</h2><h3 id=\"1-磁盘初始化\"><a href=\"#1-磁盘初始化\" class=\"headerlink\" title=\"1.磁盘初始化\"></a>1.磁盘初始化</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116161224116.png\" alt=\"image-20221116161224116\"></p>\n<h3 id=\"2-引导块\"><a href=\"#2-引导块\" class=\"headerlink\" title=\"2.引导块\"></a>2.引导块</h3><p>计算机开机时需要进行一系列初始化工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。</p>\n<p>ROM：初始化程序可以放在ROM中（）只读存储器，ROM中的数据在出厂的时候就写入了，并且以后不能修改。ROM一般出厂就集成在了主板上。</p>\n<p>现在ROM中只是存放很小的自举装入程序，完整的程序放在磁盘的启动快中，启动快位于磁盘的固定位置。</p>\n<p>拥有启动分区的磁盘统称为启动磁盘（C盘）</p>\n<h3 id=\"3-坏块管理\"><a href=\"#3-坏块管理\" class=\"headerlink\" title=\"3.坏块管理\"></a>3.坏块管理</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116162206017.png\" alt=\"image-20221116162206017\"></p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116162217903.png\" alt=\"image-20221116162217903\"></p>\n<h2 id=\"5-0-I-O设备概念\"><a href=\"#5-0-I-O设备概念\" class=\"headerlink\" title=\"5.0 I-O设备概念\"></a>5.0 I-O设备概念</h2><h3 id=\"1-I-O控制器的功能\"><a href=\"#1-I-O控制器的功能\" class=\"headerlink\" title=\"1.I-O控制器的功能\"></a>1.I-O控制器的功能</h3><p>接受和识别CPU发出的指令，向CPU报告设备的状态，数据交换，地址识别。</p>\n<h3 id=\"2-I-x2F-O控制器的组成\"><a href=\"#2-I-x2F-O控制器的组成\" class=\"headerlink\" title=\"2.I&#x2F;O控制器的组成\"></a>2.I&#x2F;O控制器的组成</h3><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221118151249884.png\" alt=\"image-20221118151249884\" style=\"zoom: 33%;\">\n\n<h3 id=\"3-总结-1\"><a href=\"#3-总结-1\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h3><p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221118151620110.png\" alt=\"image-20221118151620110\"></p>\n<h2 id=\"5-1I-x2F-O控制方式\"><a href=\"#5-1I-x2F-O控制方式\" class=\"headerlink\" title=\"5.1I&#x2F;O控制方式\"></a>5.1I&#x2F;O控制方式</h2>","text":"3.1内存的基础知识1.什么是内存1.内存是用来存放数据的硬件。程序执行钱需要先放到内存中才能被CPU处理。 3.2.装入的三种方式（完成逻辑地址到物理地址的转换）1.绝对装入在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">3.1内存的基础知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98\"><span class=\"toc-text\">1.什么是内存</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E5%AE%8C%E6%88%90%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%89\"><span class=\"toc-text\">3.2.装入的三种方式（完成逻辑地址到物理地址的转换）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5\"><span class=\"toc-text\">1.绝对装入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">2.静态重定位</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">3.动态重定位</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.链接的三种方式</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.3内存管理的概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">3.4覆盖与交换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%89%A9%E5%85%85%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">1.内存空间扩充技术</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">2.覆盖技术</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">3.交换技术</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4两者的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">3.5内存空间的分配和回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D\"><span class=\"toc-text\">1.单一连续分配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D\"><span class=\"toc-text\">2.固定分区分配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D\"><span class=\"toc-text\">3.动态分区分配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87\"><span class=\"toc-text\">1.内部碎片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87\"><span class=\"toc-text\">2.外部碎片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%B4%A7%E5%87%91\"><span class=\"toc-text\">3.紧凑</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4.总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3.6动态分区分配算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">1.首次适应算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.最佳适应算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88%E6%9C%80%E5%A4%A7%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">3.最坏适应算法（最大适应算法）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">4.邻近适应算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5.总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.7内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.分页存储管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%EF%BC%9A\"><span class=\"toc-text\">2.逻辑地址结构：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%A1%B5%E8%A1%A8\"><span class=\"toc-text\">3.页表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-8%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">3.8基本地址变换机构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-9%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">3.9具有快表的地址变换机构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.局部性原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%97%B6%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7\"><span class=\"toc-text\">1.时间局部性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7\"><span class=\"toc-text\">2.空间局部性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%BF%AB%E8%A1%A8\"><span class=\"toc-text\">2.快表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">1.地址变换过程</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-0%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8\"><span class=\"toc-text\">4.0两级页表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.单级页表存在的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.两级页表的原理、地址结构</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.1文件存储管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">4.2文件的基本操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">1.打开文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2.关闭文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%AF%BB%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3.读文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%86%99%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">4.写文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">5.总结</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">4.3文件共享</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%88%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%89\"><span class=\"toc-text\">1.基于索引节点的共享方式（硬链接）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E4%BA%8E%E7%AC%A6%E5%8F%B7%E8%BF%9E%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%88%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%89\"><span class=\"toc-text\">2.基于符号连的共享方式（软链接）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">4.4文件保护</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">1.口令保护</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">2.加密保护</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">3.访问控制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">4.总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">4.5文件系统的层次结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">4.6磁盘的结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%A3%81%E7%9B%98%EF%BC%8C%E7%A3%81%E9%81%93%EF%BC%8C%E6%89%87%E5%8C%BA\"><span class=\"toc-text\">1.磁盘，磁道，扇区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%80%8E%E4%B9%88%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB-x2F-%E5%86%99%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">2.怎么在磁盘中读&#x2F;写数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%9B%98%E9%9D%A2%EF%BC%8C%E6%9F%B1%E9%9D%A2\"><span class=\"toc-text\">3.盘面，柱面</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%A3%81%E7%9B%98%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">4.磁盘的物理地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">5.磁盘的分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">6.总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">4.7磁盘调度算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">1.磁盘读写操作需要的时间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%AF%BB%E6%89%BE%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">1.寻找时间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">2.延迟时间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">3.传输时间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%80%BB%E7%BB%93-2\"><span class=\"toc-text\">4.总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95%EF%BC%88FCFS%EF%BC%89\"><span class=\"toc-text\">1.先来先服务算法（FCFS）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%9C%80%E7%9F%AD%E5%AF%BB%E6%89%BE%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88SSTF%EF%BC%89\"><span class=\"toc-text\">2.最短寻找时间优先（SSTF）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88SCAN%EF%BC%89\"><span class=\"toc-text\">3.扫描算法（SCAN）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-LOOK%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">4.LOOK调度算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88C-SCAN%EF%BC%89\"><span class=\"toc-text\">5.循环扫描算法（C-SCAN）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-C-LOOK%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">6.C-LOOK调度算法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">3.总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-8%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.8减少延迟时间的方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BA%A4%E6%9B%BF%E7%BC%96%E5%8F%B7\"><span class=\"toc-text\">1.交替编号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">2.磁盘地址结构的设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D\"><span class=\"toc-text\">3.错位命名</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-9%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.9磁盘的管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">1.磁盘初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%BC%95%E5%AF%BC%E5%9D%97\"><span class=\"toc-text\">2.引导块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%9D%8F%E5%9D%97%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.坏块管理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-0-I-O%E8%AE%BE%E5%A4%87%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.0 I-O设备概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-I-O%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">1.I-O控制器的功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-I-x2F-O%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\">2.I&#x2F;O控制器的组成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">3.总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">5.1I&#x2F;O控制方式</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Javaweb","uid":"521d22a4a6d0170569a691b35603f80b","slug":"Javaweb","date":"2022-11-11T13:53:28.000Z","updated":"2022-11-11T14:32:58.871Z","comments":true,"path":"api/articles/Javaweb.json","keywords":null,"cover":null,"text":"1.Session（重点）1.session和cookie的区别Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个） session是把用户的数据写到用户独占的Session中，服务器端保存（保存重要信息，减少服务器资源浪费） Session由服务器创建 2.使...","link":"","photos":[],"count_time":{"symbolsCount":593,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}